# -*- generated by 1.0.12 -*-
import da
PatternExpr_503 = da.pat.TuplePattern([da.pat.ConstantPattern('r'), da.pat.FreePattern('round_i')])
PatternExpr_517 = da.pat.TuplePattern([da.pat.ConstantPattern('M'), da.pat.FreePattern('p'), da.pat.FreePattern('z'), da.pat.FreePattern('Zv')])
_config_object = {}
import sys
import math
import functools
from collections import defaultdict

class G():

    def __init__(self, weights, n):
        if (len(weights) == (n * n)):
            self.weights = weights
            self.np = n
        else:
            print('Input weights error')

    def neighbor(self, p):
        neighbor_ids = []
        neighbor_weights = self.weights[(p * self.np):((p + 1) * self.np)]
        for i in range(self.np):
            if (neighbor_weights[i] >= 0):
                neighbor_ids.append(i)
        return neighbor_ids

    def getWeight(self, i, j):
        if (self.weights[((i * self.np) + j)] < 0):
            return float('inf')
        else:
            return self.weights[((i * self.np) + j)]

class P(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_PReceivedEvent_0', PatternExpr_503, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._P_handler_502]), da.pat.EventPattern(da.pat.ReceivedEvent, '_PReceivedEvent_1', PatternExpr_517, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._P_handler_516])])

    def setup(self, neighbors, sources, clique, idmapping, G, delta, h, **rest_1229):
        super().setup(neighbors=neighbors, sources=sources, clique=clique, idmapping=idmapping, G=G, delta=delta, h=h, **rest_1229)
        self._state.neighbors = neighbors
        self._state.sources = sources
        self._state.clique = clique
        self._state.idmapping = idmapping
        self._state.G = G
        self._state.delta = delta
        self._state.h = h
        self._state.neighbors = self._state.neighbors
        self._state.d_star_dict = {}
        self._state.z_list = []
        self._state.sources = self._state.sources
        if (self._id in self._state.sources):
            self._state.is_source = True
        else:
            self._state.is_source = False
        self._state.r = 0
        self._state.delta = self._state.delta
        self._state.h = self._state.h
        self._state.G = self._state.G
        self._state.idmapping = self._state.idmapping
        self._state.clique = self._state.clique
        self._state.rcount = defaultdict((lambda : 0))
        self._state.pcount = len(self._state.clique)

    def run(self):
        self.initiate()
        while (self._state.r <= 20):
            self.msgsending()
            self.sync()
        self.output('output =', self._state.d_star_dict)

    def initiate(self):
        for p in self._state.sources:
            self._state.d_star_dict[p] = float('inf')
        if self._state.is_source:
            self._state.d_star_dict[self._id] = 0
            z = [0, 0, 0, self._id, True, None]
            self._state.z_list.append(z)

    def msgsending(self):
        for i in range(len(self._state.z_list)):
            z = self._state.z_list[i]
            if (self._state.r == int((z[0] + i))):
                cal_z = self.cal_Zv(z)
                self.send(('M', self._id, z, cal_z), to=self._state.neighbors)

    def sync(self):
        self.send(('r', self._state.r), to=self._state.clique)
        super()._label('_st_label_487', block=False)
        _st_label_487 = 0
        while (_st_label_487 == 0):
            _st_label_487 += 1
            if (self._state.rcount[self._state.r] == self._state.pcount):
                self._state.r += 1
                _st_label_487 += 1
            else:
                super()._label('_st_label_487', block=True)
                _st_label_487 -= 1

    def cal_num_of_z_list(self, li, z):
        result = 0
        for p in li:
            if ((p[0] <= z[0]) and (p[3] == z[3])):
                result += 1
        return result

    def cal_Kappa(self, d, k, h, delta, l):
        return ((d * self.gamma(k, h, delta)) + l)

    def gamma(self, k, h, delta):
        return math.sqrt(((k * h) / delta))

    def cal_Zv(self, z):
        result = 0
        index = self._state.z_list.index(z)
        for i in range((index + 1)):
            if (self._state.z_list[i][3] == z[3]):
                result += 1
        return result

    def cmpValue(self, subInfo1, subInfo2):
        if (not (subInfo1[0] == subInfo2[0])):
            return (subInfo1[0] - subInfo2[0])
        elif (not (subInfo1[1] == subInfo2[1])):
            return (subInfo1[1] - subInfo2[1])
        elif (not (subInfo1[3] == subInfo2[3])):
            return (subInfo1[3] - subInfo2[3])
        else:
            return 0

    def _P_handler_502(self, round_i):
        self._state.rcount[round_i] += 1
    _P_handler_502._labels = None
    _P_handler_502._notlabels = None

    def _P_handler_516(self, p, z, Zv):
        kappa = ((z[0] + (self._state.G.getWeight(self._state.idmapping[p], self._state.idmapping[self._id]) * self.gamma(len(self._state.neighbors), self._state.h, self._state.delta))) + 1)
        d = (z[1] + self._state.G.getWeight(self._state.idmapping[p], self._state.idmapping[self._id]))
        l = (z[2] + 1)
        new_z = [kappa, d, l, z[3], False, p]
        z_star = None
        for entry in self._state.z_list:
            if (entry[4] and (entry[3] == z[3])):
                z_star = entry
        if (z[4] and (l <= self._state.h) and ((d < self._state.d_star_dict[z[3]]) or ((d == z_star[1]) and (l < z_star[2])) or ((d == z_star[1]) and (l == z_star[2]) and (new_z[5] < z_star[p])))):
            self._state.d_star_dict[z[3]] = d
            new_z[4] = True
            if z_star:
                z_star[4] = False
            self._state.z_list.append(new_z)
            self._state.z_list.sort(key=functools.cmp_to_key(self.cmpValue))
            index_z = self._state.z_list.index(new_z)
            for i in range((index_z + 1), len(self._state.z_list)):
                z_temp = self._state.z_list[i]
                if ((z_temp[3] == new_z[3]) and (not z_temp[4])):
                    self._state.z_list.remove(z_temp)
                    break
        else:
            num_of_entries_z_list = self.cal_num_of_z_list(self._state.z_list, new_z)
            if (num_of_entries_z_list < Zv):
                self._state.z_list.append(new_z)
                self._state.z_list.sort(key=functools.cmp_to_key(self.cmpValue))
                index_z = self._state.z_list.index(new_z)
                for i in range((index_z + 1), len(self._state.z_list)):
                    z_temp = self._state.z_list[i]
                    if ((z_temp[3] == new_z[3]) and (not z_temp[4])):
                        self._state.z_list.remove(z_temp)
                        break
    _P_handler_516._labels = None
    _P_handler_516._notlabels = None

class Node_(da.NodeProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._events.extend([])
    _config_object = {'channel': 'fifo'}

    def run(self):
        n = (int(sys.argv[1]) if (len(sys.argv) > 1) else 6)
        weights = [(- 1), 2, (- 1), (- 1), (- 1), 4, 2, (- 1), (- 1), 6, (- 1), (- 1), (- 1), (- 1), (- 1), 5, (- 1), (- 1), (- 1), 6, 5, (- 1), 1, (- 1), (- 1), (- 1), (- 1), 1, (- 1), (- 1), 4, (- 1), (- 1), (- 1), (- 1), (- 1)]
        '\n    weights =[\n        -2, -1, -2,\n        -2, -2, -1,\n        -1, -2, -2\n    ]\n    '
        graph = G(weights, n)
        ps = list(self.new(P, num=n))
        sources = [ps[0], ps[1], ps[2], ps[3], ps[4], ps[5]]
        idmapping = {}
        delta = 20
        hop = 20
        for (i, p) in enumerate(ps):
            idmapping[p] = i
        self.output(idmapping)
        for (i, p) in enumerate(ps):
            neighbors = [ps[x] for x in graph.neighbor(i)]
            print(neighbors)
            self._setup({p}, (neighbors, sources, [ps[i0] for (i0, p0) in enumerate(ps)], idmapping, graph, delta, hop))
        self._start(ps)
